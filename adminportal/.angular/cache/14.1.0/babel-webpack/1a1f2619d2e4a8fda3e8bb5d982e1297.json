{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Measurable = void 0;\n\nconst canvas_1 = require(\"canvas\");\n\nconst UnicodeLineBreak_1 = require(\"./UnicodeLineBreak\");\n\nconst utils_1 = require(\"./utils\");\n\nclass Measurable {\n  constructor() {\n    this.caches = new Map();\n  }\n\n  clearCache() {\n    this.caches.clear();\n  }\n\n  getMeasuredParagraph(options) {\n    const canvas = canvas_1.createCanvas(100, 100);\n    const ctx = canvas.getContext(\"2d\");\n    return this.testBestMeasuredParagraph(Object.assign({\n      ctx\n    }, options));\n  } // the logic below may cause the last checking run one more time (but it's ok since things are cached)\n\n\n  testBestMeasuredParagraph(options) {\n    const {\n      maxWidth,\n      maxHeight,\n      maxFontSize,\n      minFontSize,\n      fontSize\n    } = options,\n          otherOptions = __rest(options, [\"maxWidth\", \"maxHeight\", \"maxFontSize\", \"minFontSize\", \"fontSize\"]);\n\n    const measuredParagraph = this.testMeasuredParagraph(Object.assign(Object.assign({}, otherOptions), {\n      maxWidth,\n      fontSize\n    }));\n    const currentHeight = options.useGlyphPadding ? measuredParagraph.boundingHeight : measuredParagraph.height;\n    const currentWidth = options.useGlyphPadding ? measuredParagraph.boundingWidth : measuredParagraph.width; // if height is within range\n\n    if (currentHeight <= maxHeight && currentWidth <= maxWidth) {\n      // we still can try to do searching\n      if (options.maxFontSize > measuredParagraph.fontSize) {\n        const newFontSize = Math.ceil((options.fontSize + options.maxFontSize) / 2);\n        return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), {\n          fontSize: newFontSize,\n          minFontSize: measuredParagraph.fontSize\n        }));\n      } else {\n        return measuredParagraph;\n      }\n    } else {\n      // if we have smaller available font size\n      if (options.minFontSize < measuredParagraph.fontSize) {\n        // we try an Log(N) guess\n        const newFontSize = Math.floor((options.fontSize + options.minFontSize) / 2);\n        return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), {\n          fontSize: newFontSize,\n          maxFontSize: measuredParagraph.fontSize - 1\n        }));\n      } else {\n        return measuredParagraph;\n      }\n    }\n  } // give information of all the lines\n\n\n  testMeasuredParagraph(options) {\n    const {\n      ctx,\n      text,\n      noAutoWrap,\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      lineHeight,\n      lineHeightMultiplier,\n      autoWrapLineHeight,\n      autoWrapLineHeightMultiplier,\n      useGlyphPadding\n    } = options;\n    const measuredWords = this.testMeasureWords({\n      ctx,\n      text,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily\n    });\n    const maxWidth = options.maxWidth; // prepare settings\n\n    const finalLineHeight = Math.round(typeof lineHeight === \"number\" ? lineHeight : typeof lineHeightMultiplier === \"number\" ? fontSize * lineHeightMultiplier : fontSize);\n    const finalAutoWrapLineHeight = Math.round(typeof autoWrapLineHeight === \"number\" ? autoWrapLineHeight : typeof autoWrapLineHeightMultiplier === \"number\" ? fontSize * autoWrapLineHeightMultiplier : finalLineHeight); // find space width first\n\n    const measuredSpace = this.testMeasuredWord(Object.assign(Object.assign({}, options), {\n      text: \" \"\n    }));\n    const spaceWidth = measuredSpace.width; // prepare canvas\n\n    let measuredLine = {\n      text: \"\",\n      width: 0,\n      paddingTop: -fontSize,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0,\n      nextLineHeight: 0,\n      measuredWords: []\n    };\n    const measuredParagraph = {\n      text,\n      width: 0,\n      height: 0,\n      fontSize,\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      spaceWidth,\n      boundingHeight: 0,\n      boundingWidth: 0,\n      paddingTop: 0,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0,\n      measuredLines: []\n    };\n    let lastMeasuredWord;\n\n    for (const measuredWord of measuredWords) {\n      // we get the last word spacing information\n      let lastWordTotalSpaceWidth = 0;\n      let lastWordSpaceCount = 0;\n\n      if (lastMeasuredWord && !lastMeasuredWord.hasLineBreak) {\n        lastWordTotalSpaceWidth = lastMeasuredWord.endingSpaceCount * spaceWidth;\n        lastWordSpaceCount = lastMeasuredWord.endingSpaceCount;\n      } // choose which width for calculation\n\n\n      let currentWidth = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n\n      if (useGlyphPadding) {\n        currentWidth += measuredWord.paddingLeft + measuredWord.paddingRight;\n      } // if we have auto Wrap & make sure each line within max width\n\n\n      if (!noAutoWrap && currentWidth > maxWidth) {\n        // we go into another line the line contains something already\n        if (measuredLine.text) {\n          measuredLine.nextLineHeight = finalAutoWrapLineHeight;\n          measuredParagraph.measuredLines.push(measuredLine);\n        } // create new line\n\n\n        measuredLine = {\n          text: measuredWord.text,\n          width: measuredWord.width,\n          paddingTop: measuredWord.paddingTop,\n          paddingBottom: measuredWord.paddingBottom,\n          paddingLeft: measuredWord.paddingLeft,\n          paddingRight: measuredWord.paddingRight,\n          nextLineHeight: 0,\n          measuredWords: []\n        };\n      } else {\n        // add the word\n        measuredLine.text += \" \".repeat(lastWordSpaceCount) + measuredWord.text;\n        measuredLine.paddingTop = Math.max(measuredLine.paddingTop, measuredWord.paddingTop);\n        measuredLine.paddingBottom = Math.max(measuredLine.paddingBottom, measuredWord.paddingBottom);\n\n        if (measuredLine.width === 0) {\n          measuredLine.paddingLeft = measuredWord.paddingLeft;\n        }\n\n        measuredLine.paddingRight = measuredWord.paddingRight;\n        measuredLine.width = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n        measuredLine.measuredWords.push(measuredWord);\n      } /// if it's not last word, do some further processing\n\n\n      if (!measuredWord.isLastWord) {\n        if (measuredWord.hasLineBreak) {\n          measuredLine.nextLineHeight = finalLineHeight;\n          measuredParagraph.measuredLines.push(measuredLine);\n          measuredLine = {\n            text: \"\",\n            width: 0,\n            paddingTop: -fontSize,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            nextLineHeight: 0,\n            measuredWords: []\n          };\n        }\n      }\n\n      lastMeasuredWord = measuredWord;\n    } // if we current measuredLine has width, add it\n\n\n    if (measuredLine.width) {\n      measuredParagraph.measuredLines.push(measuredLine);\n    } // make sure we have lines\n    // compute some final params\n\n\n    const totalLines = measuredParagraph.measuredLines.length;\n\n    if (totalLines) {\n      measuredParagraph.width = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.width), 0);\n      measuredParagraph.height = measuredParagraph.measuredLines.reduce((a, b) => a + b.nextLineHeight, measuredParagraph.fontSize);\n      const paddingTop = measuredParagraph.measuredLines[0].paddingTop;\n      const paddingBottom = measuredParagraph.measuredLines[totalLines - 1].paddingBottom;\n      measuredParagraph.paddingTop = paddingTop;\n      measuredParagraph.paddingBottom = paddingBottom;\n      measuredParagraph.boundingHeight = measuredParagraph.height + paddingTop + paddingBottom;\n      measuredParagraph.boundingWidth = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.width + b.paddingLeft + b.paddingRight), 0);\n      measuredParagraph.paddingLeft = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingLeft), -fontSize);\n      measuredParagraph.paddingRight = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingRight), -fontSize);\n    }\n\n    return measuredParagraph;\n  } // give information for all the words\n\n\n  testMeasureWords(options) {\n    const measuredWords = [];\n    const unicodeLineBreak = new UnicodeLineBreak_1.UnicodeLineBreak(options.text);\n\n    for (const item of unicodeLineBreak) {\n      const word = item.word;\n      const trimmedWord = word.trimRight();\n      const measuredWord = this.testMeasuredWord(Object.assign(Object.assign({}, options), {\n        text: trimmedWord\n      }));\n      measuredWords.push({\n        text: trimmedWord,\n        width: measuredWord.width,\n        paddingTop: measuredWord.paddingTop,\n        paddingBottom: measuredWord.paddingBottom,\n        paddingLeft: measuredWord.paddingLeft,\n        paddingRight: measuredWord.paddingRight,\n        endingSpaceCount: word.length - trimmedWord.length,\n        isLastWord: item.isLastWord,\n        hasLineBreak: item.hasLineBreak\n      });\n    }\n\n    return measuredWords;\n  }\n\n  testMeasuredWord(options) {\n    const {\n      ctx,\n      text,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily\n    } = options;\n    const fontString = utils_1.getFontString({\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily\n    });\n    ctx.font = fontString; // create font family map if not exist\n\n    if (!this.caches.has(fontString)) {\n      this.caches.set(fontString, new Map());\n    } // create font size map if not exist\n\n\n    const fontFamilyMap = this.caches.get(fontString);\n\n    if (!fontFamilyMap.has(fontSize)) {\n      fontFamilyMap.set(fontSize, new Map());\n    } // calculate the word width\n\n\n    const fontSizeMap = fontFamilyMap.get(fontSize);\n\n    if (!fontSizeMap.has(text)) {\n      const measureText = ctx.measureText(text);\n      let paddingLeft = measureText.actualBoundingBoxLeft;\n      let paddingRight = measureText.actualBoundingBoxRight - measureText.width; // Special Handling: if this is reversed type of language\n\n      if (measureText.width > 0 && measureText.actualBoundingBoxLeft / measureText.width > 0.8 && measureText.actualBoundingBoxRight / measureText.width < 0.2) {\n        paddingLeft = measureText.actualBoundingBoxLeft - measureText.width;\n        paddingRight = measureText.actualBoundingBoxRight;\n      } // console.log(text, measureText);\n      // console.log(\"measure\", `${fontStyle}, left: ${paddingLeft}, right: ${paddingRight}, ${text}`);\n\n\n      fontSizeMap.set(text, {\n        text,\n        width: measureText.width,\n        paddingTop: measureText.actualBoundingBoxAscent - fontSize,\n        paddingBottom: measureText.actualBoundingBoxDescent,\n        paddingLeft,\n        paddingRight\n      });\n    }\n\n    return fontSizeMap.get(text);\n  }\n\n}\n\nexports.Measurable = Measurable;","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","defineProperty","exports","value","Measurable","canvas_1","require","UnicodeLineBreak_1","utils_1","constructor","caches","Map","clearCache","clear","getMeasuredParagraph","options","canvas","createCanvas","ctx","getContext","testBestMeasuredParagraph","assign","maxWidth","maxHeight","maxFontSize","minFontSize","fontSize","otherOptions","measuredParagraph","testMeasuredParagraph","currentHeight","useGlyphPadding","boundingHeight","height","currentWidth","boundingWidth","width","newFontSize","Math","ceil","floor","text","noAutoWrap","fontFamily","fontStyle","fontWeight","lineHeight","lineHeightMultiplier","autoWrapLineHeight","autoWrapLineHeightMultiplier","measuredWords","testMeasureWords","finalLineHeight","round","finalAutoWrapLineHeight","measuredSpace","testMeasuredWord","spaceWidth","measuredLine","paddingTop","paddingBottom","paddingLeft","paddingRight","nextLineHeight","measuredLines","lastMeasuredWord","measuredWord","lastWordTotalSpaceWidth","lastWordSpaceCount","hasLineBreak","endingSpaceCount","push","repeat","max","isLastWord","totalLines","reduce","a","b","unicodeLineBreak","UnicodeLineBreak","item","word","trimmedWord","trimRight","fontString","getFontString","font","has","set","fontFamilyMap","get","fontSizeMap","measureText","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent"],"sources":["/mnt/r/flipkart/product_management/adminportal/node_modules/ultimate-text-to-image/build/Measurable.js"],"sourcesContent":["\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Measurable = void 0;\nconst canvas_1 = require(\"canvas\");\nconst UnicodeLineBreak_1 = require(\"./UnicodeLineBreak\");\nconst utils_1 = require(\"./utils\");\nclass Measurable {\n    constructor() {\n        this.caches = new Map();\n    }\n    clearCache() {\n        this.caches.clear();\n    }\n    getMeasuredParagraph(options) {\n        const canvas = canvas_1.createCanvas(100, 100);\n        const ctx = canvas.getContext(\"2d\");\n        return this.testBestMeasuredParagraph(Object.assign({ ctx }, options));\n    }\n    // the logic below may cause the last checking run one more time (but it's ok since things are cached)\n    testBestMeasuredParagraph(options) {\n        const { maxWidth, maxHeight, maxFontSize, minFontSize, fontSize } = options, otherOptions = __rest(options, [\"maxWidth\", \"maxHeight\", \"maxFontSize\", \"minFontSize\", \"fontSize\"]);\n        const measuredParagraph = this.testMeasuredParagraph(Object.assign(Object.assign({}, otherOptions), { maxWidth, fontSize }));\n        const currentHeight = options.useGlyphPadding ? measuredParagraph.boundingHeight : measuredParagraph.height;\n        const currentWidth = options.useGlyphPadding ? measuredParagraph.boundingWidth : measuredParagraph.width;\n        // if height is within range\n        if (currentHeight <= maxHeight && currentWidth <= maxWidth) {\n            // we still can try to do searching\n            if (options.maxFontSize > measuredParagraph.fontSize) {\n                const newFontSize = Math.ceil((options.fontSize + options.maxFontSize) / 2);\n                return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), { fontSize: newFontSize, minFontSize: measuredParagraph.fontSize }));\n            }\n            else {\n                return measuredParagraph;\n            }\n        }\n        else {\n            // if we have smaller available font size\n            if (options.minFontSize < measuredParagraph.fontSize) {\n                // we try an Log(N) guess\n                const newFontSize = Math.floor((options.fontSize + options.minFontSize) / 2);\n                return this.testBestMeasuredParagraph(Object.assign(Object.assign({}, options), { fontSize: newFontSize, maxFontSize: measuredParagraph.fontSize - 1 }));\n            }\n            else {\n                return measuredParagraph;\n            }\n        }\n    }\n    // give information of all the lines\n    testMeasuredParagraph(options) {\n        const { ctx, text, noAutoWrap, fontFamily, fontStyle, fontWeight, fontSize, lineHeight, lineHeightMultiplier, autoWrapLineHeight, autoWrapLineHeightMultiplier, useGlyphPadding, } = options;\n        const measuredWords = this.testMeasureWords({ ctx, text, fontStyle, fontWeight, fontSize, fontFamily });\n        const maxWidth = options.maxWidth;\n        // prepare settings\n        const finalLineHeight = Math.round(typeof lineHeight === \"number\" ? lineHeight :\n            (typeof lineHeightMultiplier === \"number\" ? fontSize * lineHeightMultiplier : fontSize));\n        const finalAutoWrapLineHeight = Math.round(typeof autoWrapLineHeight === \"number\" ? autoWrapLineHeight :\n            (typeof autoWrapLineHeightMultiplier === \"number\" ? fontSize * autoWrapLineHeightMultiplier : finalLineHeight));\n        // find space width first\n        const measuredSpace = this.testMeasuredWord(Object.assign(Object.assign({}, options), { text: \" \" }));\n        const spaceWidth = measuredSpace.width;\n        // prepare canvas\n        let measuredLine = {\n            text: \"\",\n            width: 0,\n            paddingTop: -fontSize,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            nextLineHeight: 0,\n            measuredWords: [],\n        };\n        const measuredParagraph = {\n            text,\n            width: 0,\n            height: 0,\n            fontSize,\n            fontFamily,\n            fontStyle,\n            fontWeight,\n            spaceWidth,\n            boundingHeight: 0,\n            boundingWidth: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            measuredLines: [],\n        };\n        let lastMeasuredWord;\n        for (const measuredWord of measuredWords) {\n            // we get the last word spacing information\n            let lastWordTotalSpaceWidth = 0;\n            let lastWordSpaceCount = 0;\n            if (lastMeasuredWord && !lastMeasuredWord.hasLineBreak) {\n                lastWordTotalSpaceWidth = lastMeasuredWord.endingSpaceCount * spaceWidth;\n                lastWordSpaceCount = lastMeasuredWord.endingSpaceCount;\n            }\n            // choose which width for calculation\n            let currentWidth = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n            if (useGlyphPadding) {\n                currentWidth += measuredWord.paddingLeft + measuredWord.paddingRight;\n            }\n            // if we have auto Wrap & make sure each line within max width\n            if (!noAutoWrap && currentWidth > maxWidth) {\n                // we go into another line the line contains something already\n                if (measuredLine.text) {\n                    measuredLine.nextLineHeight = finalAutoWrapLineHeight;\n                    measuredParagraph.measuredLines.push(measuredLine);\n                }\n                // create new line\n                measuredLine = {\n                    text: measuredWord.text,\n                    width: measuredWord.width,\n                    paddingTop: measuredWord.paddingTop,\n                    paddingBottom: measuredWord.paddingBottom,\n                    paddingLeft: measuredWord.paddingLeft,\n                    paddingRight: measuredWord.paddingRight,\n                    nextLineHeight: 0,\n                    measuredWords: [],\n                };\n            }\n            else {\n                // add the word\n                measuredLine.text += (\" \".repeat(lastWordSpaceCount) + measuredWord.text);\n                measuredLine.paddingTop = Math.max(measuredLine.paddingTop, measuredWord.paddingTop);\n                measuredLine.paddingBottom = Math.max(measuredLine.paddingBottom, measuredWord.paddingBottom);\n                if (measuredLine.width === 0) {\n                    measuredLine.paddingLeft = measuredWord.paddingLeft;\n                }\n                measuredLine.paddingRight = measuredWord.paddingRight;\n                measuredLine.width = measuredLine.width + lastWordTotalSpaceWidth + measuredWord.width;\n                measuredLine.measuredWords.push(measuredWord);\n            }\n            /// if it's not last word, do some further processing\n            if (!measuredWord.isLastWord) {\n                if (measuredWord.hasLineBreak) {\n                    measuredLine.nextLineHeight = finalLineHeight;\n                    measuredParagraph.measuredLines.push(measuredLine);\n                    measuredLine = {\n                        text: \"\",\n                        width: 0,\n                        paddingTop: -fontSize,\n                        paddingBottom: 0,\n                        paddingLeft: 0,\n                        paddingRight: 0,\n                        nextLineHeight: 0,\n                        measuredWords: [],\n                    };\n                }\n            }\n            lastMeasuredWord = measuredWord;\n        }\n        // if we current measuredLine has width, add it\n        if (measuredLine.width) {\n            measuredParagraph.measuredLines.push(measuredLine);\n        }\n        // make sure we have lines\n        // compute some final params\n        const totalLines = measuredParagraph.measuredLines.length;\n        if (totalLines) {\n            measuredParagraph.width = measuredParagraph.measuredLines\n                .reduce((a, b) => Math.max(a, b.width), 0);\n            measuredParagraph.height = measuredParagraph.measuredLines\n                .reduce((a, b) => a + b.nextLineHeight, measuredParagraph.fontSize);\n            const paddingTop = measuredParagraph.measuredLines[0].paddingTop;\n            const paddingBottom = measuredParagraph.measuredLines[totalLines - 1].paddingBottom;\n            measuredParagraph.paddingTop = paddingTop;\n            measuredParagraph.paddingBottom = paddingBottom;\n            measuredParagraph.boundingHeight = measuredParagraph.height + paddingTop + paddingBottom;\n            measuredParagraph.boundingWidth = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.width + b.paddingLeft + b.paddingRight), 0);\n            measuredParagraph.paddingLeft = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingLeft), -fontSize);\n            measuredParagraph.paddingRight = measuredParagraph.measuredLines.reduce((a, b) => Math.max(a, b.paddingRight), -fontSize);\n        }\n        return measuredParagraph;\n    }\n    // give information for all the words\n    testMeasureWords(options) {\n        const measuredWords = [];\n        const unicodeLineBreak = new UnicodeLineBreak_1.UnicodeLineBreak(options.text);\n        for (const item of unicodeLineBreak) {\n            const word = item.word;\n            const trimmedWord = word.trimRight();\n            const measuredWord = this.testMeasuredWord(Object.assign(Object.assign({}, options), { text: trimmedWord }));\n            measuredWords.push({\n                text: trimmedWord,\n                width: measuredWord.width,\n                paddingTop: measuredWord.paddingTop,\n                paddingBottom: measuredWord.paddingBottom,\n                paddingLeft: measuredWord.paddingLeft,\n                paddingRight: measuredWord.paddingRight,\n                endingSpaceCount: word.length - trimmedWord.length,\n                isLastWord: item.isLastWord,\n                hasLineBreak: item.hasLineBreak,\n            });\n        }\n        return measuredWords;\n    }\n    testMeasuredWord(options) {\n        const { ctx, text, fontStyle, fontWeight, fontSize, fontFamily } = options;\n        const fontString = utils_1.getFontString({ fontStyle, fontWeight, fontSize, fontFamily });\n        ctx.font = fontString;\n        // create font family map if not exist\n        if (!this.caches.has(fontString)) {\n            this.caches.set(fontString, new Map());\n        }\n        // create font size map if not exist\n        const fontFamilyMap = this.caches.get(fontString);\n        if (!fontFamilyMap.has(fontSize)) {\n            fontFamilyMap.set(fontSize, new Map());\n        }\n        // calculate the word width\n        const fontSizeMap = fontFamilyMap.get(fontSize);\n        if (!fontSizeMap.has(text)) {\n            const measureText = ctx.measureText(text);\n            let paddingLeft = measureText.actualBoundingBoxLeft;\n            let paddingRight = measureText.actualBoundingBoxRight - measureText.width;\n            // Special Handling: if this is reversed type of language\n            if (measureText.width > 0 &&\n                measureText.actualBoundingBoxLeft / measureText.width > 0.8 &&\n                measureText.actualBoundingBoxRight / measureText.width < 0.2) {\n                paddingLeft = measureText.actualBoundingBoxLeft - measureText.width;\n                paddingRight = measureText.actualBoundingBoxRight;\n            }\n            // console.log(text, measureText);\n            // console.log(\"measure\", `${fontStyle}, left: ${paddingLeft}, right: ${paddingRight}, ${text}`);\n            fontSizeMap.set(text, {\n                text,\n                width: measureText.width,\n                paddingTop: measureText.actualBoundingBoxAscent - fontSize,\n                paddingBottom: measureText.actualBoundingBoxDescent,\n                paddingLeft,\n                paddingRight,\n            });\n        }\n        return fontSizeMap.get(text);\n    }\n}\nexports.Measurable = Measurable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}