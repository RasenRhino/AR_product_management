{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UltimateTextToImage = void 0;\n\nconst canvas_1 = require(\"canvas\");\n\nconst BaseClass_1 = require(\"./BaseClass\");\n\nconst Measurable_1 = require(\"./Measurable\");\n\nconst canvas_2 = require(\"./utils/canvas\");\n\nclass UltimateTextToImage extends BaseClass_1.BaseClass {\n  constructor(text, options = {}, renderOptions = {}) {\n    super();\n    this.text = text;\n    this.options = options;\n    this.renderOptions = renderOptions;\n    this._defaultOptions = {\n      width: undefined,\n      height: undefined,\n      maxWidth: undefined,\n      maxHeight: undefined,\n      noAutoWrap: false,\n      fontFamily: \"Arial\",\n      fontWeight: false,\n      fontStyle: false,\n      fontSize: 24,\n      minFontSize: undefined,\n      fontColor: \"#333333\",\n      strokeSize: 0,\n      strokeColor: \"#000000\",\n      lineHeight: undefined,\n      lineHeightMultiplier: undefined,\n      autoWrapLineHeight: undefined,\n      autoWrapLineHeightMultiplier: undefined,\n      margin: 0,\n      marginLeft: undefined,\n      marginTop: undefined,\n      marginRight: undefined,\n      marginBottom: undefined,\n      useGlyphPadding: true,\n      chopOverflow: false,\n      align: \"left\",\n      valign: \"top\",\n      alignToCenterIfHeightLE: 0,\n      alignToCenterIfLinesLE: 0,\n      borderColor: \"#000000\",\n      borderSize: 0,\n      backgroundColor: \"\",\n      underlineSize: 0,\n      underlineColor: \"\",\n      images: [],\n      nestedAlign: undefined,\n      nestedValign: undefined\n    };\n  }\n\n  get measuredParagraph() {\n    this._checkHasRendered();\n\n    return this._measuredParagraph;\n  }\n\n  render() {\n    this._startTimer();\n\n    this._createCanvas();\n\n    this._endTimer();\n\n    return this;\n  } // draw the image based on various options\n\n\n  _createCanvas() {\n    const text = this.text; // merge default options\n\n    const options = Object.assign({}, this._defaultOptions, this.options); // prepare all variables\n\n    const {\n      height,\n      width,\n      noAutoWrap,\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      chopOverflow,\n      useGlyphPadding,\n      underlineSize,\n      underlineColor,\n      images\n    } = options;\n    let {\n      maxWidth,\n      maxHeight,\n      minFontSize\n    } = options; // work on default values\n\n    maxHeight = typeof maxHeight === \"number\" ? maxHeight : typeof height === \"number\" ? height : UltimateTextToImage.maxSize;\n    maxWidth = typeof maxWidth === \"number\" ? maxWidth : typeof width === \"number\" ? width : UltimateTextToImage.maxSize; // update max size\n\n    maxWidth = Math.max(width || 1, maxWidth);\n    maxHeight = Math.max(height || 1, maxHeight);\n    minFontSize = typeof minFontSize === \"number\" ? minFontSize : options.fontSize;\n    const marginLeft = typeof options.marginLeft === \"number\" ? options.marginLeft : options.margin;\n    const marginTop = typeof options.marginTop === \"number\" ? options.marginTop : options.margin;\n    const marginRight = typeof options.marginRight === \"number\" ? options.marginRight : options.margin;\n    const marginBottom = typeof options.marginBottom === \"number\" ? options.marginBottom : options.margin; // find the best measured paragraph\n\n    const measuredParagraph = UltimateTextToImage.measurable.getMeasuredParagraph({\n      text,\n      maxWidth: maxWidth - marginLeft - marginRight,\n      maxHeight: maxHeight - marginTop - marginBottom,\n      noAutoWrap,\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      maxFontSize: fontSize,\n      minFontSize,\n      fontSize,\n      useGlyphPadding,\n      lineHeight: options.lineHeight,\n      lineHeightMultiplier: options.lineHeightMultiplier,\n      autoWrapLineHeight: options.autoWrapLineHeight,\n      autoWrapLineHeightMultiplier: options.autoWrapLineHeightMultiplier\n    }); // prepared update varaibles\n\n    const finalFontSize = measuredParagraph.fontSize; // update the alignments\n\n    let finalValign = options.valign;\n    let finalAlign = options.align;\n    const desiredCanvasHeight = measuredParagraph.height + marginTop + marginBottom;\n    const desiredCanvasBoundingHeight = measuredParagraph.boundingHeight + marginTop + marginBottom;\n    const desiredCanvasWidth = measuredParagraph.width + marginLeft + marginRight;\n    const desiredCanvasBoundingWidth = measuredParagraph.boundingWidth + marginLeft + marginRight;\n    let finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasHeight, Math.min(maxHeight, desiredCanvasHeight));\n    let finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasWidth, Math.min(maxWidth, desiredCanvasWidth));\n\n    if (options.alignToCenterIfHeightLE && measuredParagraph.height <= options.alignToCenterIfHeightLE) {\n      finalValign = \"middle\";\n      finalAlign = \"center\";\n    }\n\n    if (options.alignToCenterIfLinesLE && measuredParagraph.measuredLines.length <= options.alignToCenterIfLinesLE) {\n      finalValign = \"middle\";\n      finalAlign = \"center\";\n    } // if we want more precise spacing\n\n\n    if (useGlyphPadding) {\n      finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasBoundingHeight, Math.min(maxHeight, desiredCanvasBoundingHeight));\n      finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasBoundingWidth, Math.min(maxWidth, desiredCanvasBoundingWidth));\n    } // update the object values\n\n\n    finalWidth = Math.max(1, finalWidth);\n    finalHeight = Math.max(1, finalHeight);\n    this._measuredParagraph = measuredParagraph;\n    this._canvas = canvas_1.createCanvas(finalWidth, finalHeight);\n\n    const ctx = this._canvas.getContext(\"2d\"); // hook\n\n\n    canvas_2.renderHook(this._canvas, this.renderOptions.preRender); // draw images\n\n    canvas_2.drawImages(ctx, {\n      width: finalWidth,\n      height: finalHeight,\n      layer: -1,\n      images\n    }); // draw background\n\n    canvas_2.drawBackgroundColor(ctx, {\n      color: options.backgroundColor\n    }); // draw border\n\n    canvas_2.drawBorder(ctx, {\n      color: options.borderColor,\n      size: options.borderSize\n    }); // draw images\n\n    canvas_2.drawImages(ctx, {\n      width: finalWidth,\n      height: finalHeight,\n      layer: 0,\n      images\n    }); // draw texts\n\n    canvas_2.drawTexts(ctx, {\n      measuredParagraph,\n      width: finalWidth,\n      height: finalHeight,\n      fontFamily,\n      fontStyle: options.fontStyle,\n      fontWeight: options.fontWeight,\n      fontSize: finalFontSize,\n      fontColor: options.fontColor,\n      strokeSize: options.strokeSize,\n      strokeColor: options.strokeColor,\n      valign: finalValign,\n      align: finalAlign,\n      // margin: options.margin,\n      marginLeft,\n      marginTop,\n      marginRight,\n      marginBottom,\n      chopOverflow,\n      useGlyphPadding,\n      underlineSize,\n      underlineColor\n    });\n    canvas_2.drawImages(ctx, {\n      width: finalWidth,\n      height: finalHeight,\n      layer: 1,\n      images\n    }); // hook\n\n    canvas_2.renderHook(this._canvas, this.renderOptions.posRender);\n    return this._canvas;\n  }\n\n}\n\nexports.UltimateTextToImage = UltimateTextToImage;\nUltimateTextToImage.measurable = new Measurable_1.Measurable();\nUltimateTextToImage.maxSize = 2 << 14 - 1;","map":{"version":3,"names":["Object","defineProperty","exports","value","UltimateTextToImage","canvas_1","require","BaseClass_1","Measurable_1","canvas_2","BaseClass","constructor","text","options","renderOptions","_defaultOptions","width","undefined","height","maxWidth","maxHeight","noAutoWrap","fontFamily","fontWeight","fontStyle","fontSize","minFontSize","fontColor","strokeSize","strokeColor","lineHeight","lineHeightMultiplier","autoWrapLineHeight","autoWrapLineHeightMultiplier","margin","marginLeft","marginTop","marginRight","marginBottom","useGlyphPadding","chopOverflow","align","valign","alignToCenterIfHeightLE","alignToCenterIfLinesLE","borderColor","borderSize","backgroundColor","underlineSize","underlineColor","images","nestedAlign","nestedValign","measuredParagraph","_checkHasRendered","_measuredParagraph","render","_startTimer","_createCanvas","_endTimer","assign","maxSize","Math","max","measurable","getMeasuredParagraph","maxFontSize","finalFontSize","finalValign","finalAlign","desiredCanvasHeight","desiredCanvasBoundingHeight","boundingHeight","desiredCanvasWidth","desiredCanvasBoundingWidth","boundingWidth","finalHeight","min","finalWidth","measuredLines","length","_canvas","createCanvas","ctx","getContext","renderHook","preRender","drawImages","layer","drawBackgroundColor","color","drawBorder","size","drawTexts","posRender","Measurable"],"sources":["/mnt/r/flipkart/product_management/adminportal/node_modules/ultimate-text-to-image/build/UltimateTextToImage.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UltimateTextToImage = void 0;\nconst canvas_1 = require(\"canvas\");\nconst BaseClass_1 = require(\"./BaseClass\");\nconst Measurable_1 = require(\"./Measurable\");\nconst canvas_2 = require(\"./utils/canvas\");\nclass UltimateTextToImage extends BaseClass_1.BaseClass {\n    constructor(text, options = {}, renderOptions = {}) {\n        super();\n        this.text = text;\n        this.options = options;\n        this.renderOptions = renderOptions;\n        this._defaultOptions = {\n            width: undefined,\n            height: undefined,\n            maxWidth: undefined,\n            maxHeight: undefined,\n            noAutoWrap: false,\n            fontFamily: \"Arial\",\n            fontWeight: false,\n            fontStyle: false,\n            fontSize: 24,\n            minFontSize: undefined,\n            fontColor: \"#333333\",\n            strokeSize: 0,\n            strokeColor: \"#000000\",\n            lineHeight: undefined,\n            lineHeightMultiplier: undefined,\n            autoWrapLineHeight: undefined,\n            autoWrapLineHeightMultiplier: undefined,\n            margin: 0,\n            marginLeft: undefined,\n            marginTop: undefined,\n            marginRight: undefined,\n            marginBottom: undefined,\n            useGlyphPadding: true,\n            chopOverflow: false,\n            align: \"left\",\n            valign: \"top\",\n            alignToCenterIfHeightLE: 0,\n            alignToCenterIfLinesLE: 0,\n            borderColor: \"#000000\",\n            borderSize: 0,\n            backgroundColor: \"\",\n            underlineSize: 0,\n            underlineColor: \"\",\n            images: [],\n            nestedAlign: undefined,\n            nestedValign: undefined,\n        };\n    }\n    get measuredParagraph() {\n        this._checkHasRendered();\n        return this._measuredParagraph;\n    }\n    render() {\n        this._startTimer();\n        this._createCanvas();\n        this._endTimer();\n        return this;\n    }\n    // draw the image based on various options\n    _createCanvas() {\n        const text = this.text;\n        // merge default options\n        const options = Object.assign({}, this._defaultOptions, this.options);\n        // prepare all variables\n        const { height, width, noAutoWrap, fontFamily, fontStyle, fontWeight, fontSize, chopOverflow, useGlyphPadding, underlineSize, underlineColor, images, } = options;\n        let { maxWidth, maxHeight, minFontSize } = options;\n        // work on default values\n        maxHeight = typeof maxHeight === \"number\" ? maxHeight : (typeof height === \"number\" ? height : UltimateTextToImage.maxSize);\n        maxWidth = typeof maxWidth === \"number\" ? maxWidth : (typeof width === \"number\" ? width : UltimateTextToImage.maxSize);\n        // update max size\n        maxWidth = Math.max(width || 1, maxWidth);\n        maxHeight = Math.max(height || 1, maxHeight);\n        minFontSize = typeof minFontSize === \"number\" ? minFontSize : options.fontSize;\n        const marginLeft = typeof options.marginLeft === \"number\" ? options.marginLeft : options.margin;\n        const marginTop = typeof options.marginTop === \"number\" ? options.marginTop : options.margin;\n        const marginRight = typeof options.marginRight === \"number\" ? options.marginRight : options.margin;\n        const marginBottom = typeof options.marginBottom === \"number\" ? options.marginBottom : options.margin;\n        // find the best measured paragraph\n        const measuredParagraph = UltimateTextToImage.measurable.getMeasuredParagraph({\n            text,\n            maxWidth: maxWidth - marginLeft - marginRight,\n            maxHeight: maxHeight - marginTop - marginBottom,\n            noAutoWrap,\n            fontFamily,\n            fontStyle,\n            fontWeight,\n            maxFontSize: fontSize,\n            minFontSize,\n            fontSize,\n            useGlyphPadding,\n            lineHeight: options.lineHeight,\n            lineHeightMultiplier: options.lineHeightMultiplier,\n            autoWrapLineHeight: options.autoWrapLineHeight,\n            autoWrapLineHeightMultiplier: options.autoWrapLineHeightMultiplier,\n        });\n        // prepared update varaibles\n        const finalFontSize = measuredParagraph.fontSize;\n        // update the alignments\n        let finalValign = options.valign;\n        let finalAlign = options.align;\n        const desiredCanvasHeight = measuredParagraph.height + marginTop + marginBottom;\n        const desiredCanvasBoundingHeight = measuredParagraph.boundingHeight + marginTop + marginBottom;\n        const desiredCanvasWidth = measuredParagraph.width + marginLeft + marginRight;\n        const desiredCanvasBoundingWidth = measuredParagraph.boundingWidth + marginLeft + marginRight;\n        let finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasHeight, Math.min(maxHeight, desiredCanvasHeight));\n        let finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasWidth, Math.min(maxWidth, desiredCanvasWidth));\n        if (options.alignToCenterIfHeightLE && measuredParagraph.height <= options.alignToCenterIfHeightLE) {\n            finalValign = \"middle\";\n            finalAlign = \"center\";\n        }\n        if (options.alignToCenterIfLinesLE && measuredParagraph.measuredLines.length <= options.alignToCenterIfLinesLE) {\n            finalValign = \"middle\";\n            finalAlign = \"center\";\n        }\n        // if we want more precise spacing\n        if (useGlyphPadding) {\n            finalHeight = Math.max(typeof height === \"number\" ? height : desiredCanvasBoundingHeight, Math.min(maxHeight, desiredCanvasBoundingHeight));\n            finalWidth = Math.max(typeof width === \"number\" ? width : desiredCanvasBoundingWidth, Math.min(maxWidth, desiredCanvasBoundingWidth));\n        }\n        // update the object values\n        finalWidth = Math.max(1, finalWidth);\n        finalHeight = Math.max(1, finalHeight);\n        this._measuredParagraph = measuredParagraph;\n        this._canvas = canvas_1.createCanvas(finalWidth, finalHeight);\n        const ctx = this._canvas.getContext(\"2d\");\n        // hook\n        canvas_2.renderHook(this._canvas, this.renderOptions.preRender);\n        // draw images\n        canvas_2.drawImages(ctx, { width: finalWidth, height: finalHeight, layer: -1, images });\n        // draw background\n        canvas_2.drawBackgroundColor(ctx, { color: options.backgroundColor });\n        // draw border\n        canvas_2.drawBorder(ctx, { color: options.borderColor, size: options.borderSize });\n        // draw images\n        canvas_2.drawImages(ctx, { width: finalWidth, height: finalHeight, layer: 0, images });\n        // draw texts\n        canvas_2.drawTexts(ctx, {\n            measuredParagraph,\n            width: finalWidth,\n            height: finalHeight,\n            fontFamily,\n            fontStyle: options.fontStyle,\n            fontWeight: options.fontWeight,\n            fontSize: finalFontSize,\n            fontColor: options.fontColor,\n            strokeSize: options.strokeSize,\n            strokeColor: options.strokeColor,\n            valign: finalValign,\n            align: finalAlign,\n            // margin: options.margin,\n            marginLeft,\n            marginTop,\n            marginRight,\n            marginBottom,\n            chopOverflow,\n            useGlyphPadding,\n            underlineSize,\n            underlineColor,\n        });\n        canvas_2.drawImages(ctx, { width: finalWidth, height: finalHeight, layer: 1, images });\n        // hook\n        canvas_2.renderHook(this._canvas, this.renderOptions.posRender);\n        return this._canvas;\n    }\n}\nexports.UltimateTextToImage = UltimateTextToImage;\nUltimateTextToImage.measurable = new Measurable_1.Measurable();\nUltimateTextToImage.maxSize = 2 << 14 - 1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}